import java.util.Arrays;
import java.util.Random;
import java.util.Stack;

public class CategoryB {

    /**
     * Метод, определяющий, является ли строка правильной скобочной последовательностью
     *
     * @param s - строка
     */
    public static void task1(String s) {
        // Вывод на экран входных данных для наглядности и удобства проверки
        System.out.println("Input:\n" + s);
        System.out.println("Output:");
        // ---------

        // Стек, в котором будем хранить открывающие, на данный момент неспаренные, скобки
        Stack<Character> stack = new Stack<>();
        boolean ok = true; // переменная, true если последовательность скобок правильная
        // проходим по строке
        for (int i = 0; ok && (i < s.length()); ++i) {
            char cur = s.charAt(i); // текущий символ
            switch (cur) {
                // если пробел, игнорируем
                case ' ':
                    break;
                // если открывающая скобка, добавляем в стек
                case '(':
                case '[':
                case '{':
                    stack.push(new Character(cur));
                    break;
                // если закрывающая скобка, надо проверить следующее:
                // если стек пуст, то значит, эта закрывающая скобка не к месту, и последовательность неверная
                // если последняя открывающая скобка не такого же типа, что и текущая закрывающая, то последовательность неверная
                // иначе, последняя открывающая скобка имеет в паре текущую закрывающую, и эту открывающую нужно удалить из стека
                case ')':
                    if (stack.empty() || stack.peek().charValue() != '(') {
                        ok = false;
                    } else {
                        stack.pop();
                    }
                    break;
                case ']':
                    if (stack.empty() || stack.peek().charValue() != '[') {
                        ok = false;
                    } else {
                        stack.pop();
                    }
                    break;
                case '}':
                    if (stack.empty() || stack.peek().charValue() != '{') {
                        ok = false;
                    } else {
                        stack.pop();
                    }
                    break;
            }
        }
        // Если последовательность была верная, то в конце стек должен остаться пустым (все скобки должны закрыться)
        if (!stack.empty()) {
            ok = false;
        }
        System.out.println(ok ? "SUCCESS" : "FAIL");
    }

    /**
     * Метод, генерирующий массив из n^2 случайных элементов и выводящий на экран его элементы в порядке возрастания
     * в виде матрицы n x n по спирали и по змейке.
     * @param n - число n
     */
    public static void task2(int n) {
        // Вывод на экран входных данных для наглядности и удобства проверки
        System.out.println("Input:\nn = " + n);
        // ---------
        if (n <= 0) {
            System.out.println("Output:\nInvalid number");
        } else {
            final Random random = new Random();

            int[] a = new int[n * n]; // массив "source"
            for (int i = 0; i < n * n; ++i) {
                a[i] = random.nextInt(1000);
            }
            System.out.println("source = " + Arrays.toString(a));

            Arrays.sort(a); // сортируем массив по возрастанию

            System.out.println("Output:");

            System.out.println("spiral");
            // _________________SPIRAL__________________
            {
                int k = 0; // счетчик по массиву a

                int[][] m = new int[n][n]; // матрица, которая будет представлять собой ответ
                int x = 0; // счетчик для строки матрицы
                int y = 0; // счетчик для столбца матрицы

                // steps - сколько шагов надо сделать в определенном направлении до смены направления
                int steps = n - 1;
                // заполнение первой строки
                for (int i = 1; i <= steps; ++i, ++k, ++y) {
                    m[x][y] = a[k];
                }
                // В следующем цикле происходит декремент steps на 2. Он закончится либо на steps == 0 (значит, что
                // движение по спирали окончено), либо на steps == 1, значит, надо сделать еще шаг ↓ и ←.
                // Поэтому эта ситуация обработана отдельным if-ом, в котором "происходит" половина того, что делается в цикле
                while (steps > 1) {
                    // ↓
                    for (int i = 1; i <= steps; ++i, ++k, ++x) {
                        m[x][y] = a[k];
                    }
                    // ←
                    for (int i = 1; i <= steps; ++i, ++k, --y) {
                        m[x][y] = a[k];
                    }
                    --steps; // дальше надо делать на один шаг меньше
                    // ↑
                    for (int i = 1; i <= steps; ++i, ++k, --x) {
                        m[x][y] = a[k];
                    }
                    // →
                    for (int i = 1; i <= steps; ++i, ++k, ++y) {
                        m[x][y] = a[k];
                    }
                    --steps; // дальше надо делать на один шаг меньше
                }
                if (steps == 1) {
                    // ↓
                    for (int i = 1; i <= steps; ++i, ++k, ++x) {
                        m[x][y] = a[k];
                    }
                    // ←
                    for (int i = 1; i <= steps; ++i, ++k, --y) {
                        m[x][y] = a[k];
                    }
                }
                // все индексы "остановились" на последней ячейке, заполняем её
                m[x][y] = a[k];

                // вывод
                for (int[] mi : m) {
                    for (int i : mi) {
                        System.out.print("" + i + " ");
                    }
                    System.out.println();
                }
            }
            // _____________END-SPIRAL_______________

            System.out.println("snake");
            // ______________SNAKE___________________
            if (n == 1) { // Если n == 1, просто выводим один-единственный элемент
                System.out.println(a[0]);
            } else {
                int k = 0; // счетчик по массиву a

                int[][] m = new int[n][n]; // матрица, которая будет представлять собой ответ
                int x = 0; // счетчик для строки матрицы
                int y = 0; // счетчик для столбца матрицы

                // Отслеживатели направления движения
                boolean normMoveRight = true;   // true: → | false: ↓
                boolean diagMoveSW = true;      // true: ↓← | false: ↑→

                m[x][y] = a[k]; // заполним первый элемент

                // steps -- сколько шагов придется сделать по диагонали
                int inc = 1; // будем увеличивать steps на 1
                for (int steps = 1; steps >= 1; steps += inc) {
                    // сдвиг на одну ячейку в другую диагональ
                    if (normMoveRight) {
                        ++y;
                    } else {
                        ++x;
                    }
                    ++k;
                    m[x][y] = a[k]; // присваиваем

                    // движение по диагонали
                    for (int i = 1; i <= steps; ++i) {
                        if (diagMoveSW) {
                            ++x;
                            --y;
                        } else {
                            --x;
                            ++y;
                        }
                        ++k;
                        m[x][y] = a[k]; // присваиваем
                    }

                    // если мы сейчас на самой большой диагонали, то далее надо уменьшать steps на 1
                    // (и не менять направление сдвига в другую диагональ)
                    if (steps == n - 1) {
                        inc = -1;
                    } else {
                        // иначе, надо менять направление сдвига в другую диагональ
                        normMoveRight = !normMoveRight;
                    }
                    // сообщаем, что по следующей диагонали мы будем двигаться в другую сторону
                    diagMoveSW = !diagMoveSW;

                }
                // после того, как всё прошли, осталась только последняя ячейка, попадаем в нее и заполняем
                m[x][++y] = a[++k];

                // вывод
                for (int[] mi : m) {
                    for (int i : mi) {
                        System.out.print("" + i + " ");
                    }
                    System.out.println();
                }
            }
            // ___________END-SNAKE___________
        }

    }

    /**
     * Метод, генерирующий по заданному числу n матрицу размера n x n и ищущий в ней минимальный по весу путь
     * из клетки (1, 1) в клетку (n, n)
     * @param n - размер матрицы
     */
    public static void task3(int n) {
        // Вывод на экран входных данных для наглядности и удобства проверки
        System.out.println("Input:\nn = " + n);
        // ---------
        if (n <= 0) {
            System.out.println("Output:\nInvalid number");
        } else {
            final Random random = new Random();

            System.out.println("matrix:");
            // заполняем и выводим матрицу
            int[][] a = new int[n][n];
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    a[i][j] = random.nextInt(100);

                    System.out.print(String.valueOf(a[i][j]) + " ");
                }
                System.out.println();
            }

            // Будем решать задачу логикой динамического программирования.

            // массив, в котором в клетке (i, j) хранится суммарный вес пути от клетки (0, 0) до клетки (i, j)
            int[][] d = new int[n][n];
            // массив "предков" - массив, в котором для каждой клетки (i, j) будем хранить обозначение для предыдущей по пути
            // клетки (слева или сверху), из которой путь в эту клетку меньше
            int[][] parent = new int[n][n]; // -1 - слева | +1 - сверху | 0 - для клетки (0, 0) (у нее нет предыдущей)
            // массив для трассировки пути при выводе
            // onPath[i][j] == true, если клетка (i, j) входит в искомый путь
            boolean[][] onPath = new boolean[n][n];

            // начальные значения
            d[0][0] = a[0][0];
            parent[0][0] = 0;

            // Запонляем самую верхнюю строку и самый левый столбец матрицы d. Для каждой из этих клеток существует
            // по единственному пути, ведущему в нее, только по верхней строке или только по левому столбцу соответственно.
            // Исходя из этих соображений заполняем веса путей, и правильно заполняем массив "предков"
            for (int i = 1; i < n; ++i){
                d[0][i] = d[0][i-1] + a[0][i];
                parent[0][i] = -1;
                d[i][0] = d[i-1][0] + a[i][0];
                parent[i][0] = 1;
            }
            // Далее проходим по клеткам ниже первой строки и правее первого столбца. Оптимальный вес пути в клетку (i, j) --
            // это минимум из двух чисел: вес пути в клетку слева плюс a[i][j] и вес пути в клетку сверху плюс a[i][j].
            // В зависимости от того, какое из этих числе меньше, мы правильно заполняем d[i][j] (этим минимумом) и
            // правильно указываем "предка"
            for (int i = 1; i < n; ++i){
                for (int j = 1; j < n; ++j){
                    int leftD = d[i][j-1] + a[i][j];
                    int upD = d[i-1][j] + a[i][j];
                    if (upD <= leftD){
                        d[i][j] = upD;
                        parent[i][j] = 1;
                    } else {
                        d[i][j] = leftD;
                        parent[i][j] = -1;
                    }
                }
            }
            // Теперь восстановим путь
            // Становимся в правую нижнюю клетку (конечную)
            int x = n - 1;
            int y = n - 1;
            // она лежит на пути
            onPath[x][y] = true;
            // проходим по клеткам, значение parent[x][y] говорит нам, куда сдвигаться дальше
            // при сдвиге указываем, что очередная клетка входит в искомый путь
            // так делаем, пока parent[x][y] != 0, т.е. пока не дошли до начальной клетки
            while (parent[x][y] != 0){
                if (parent[x][y] == 1){
                    // сдвигаемся вверх
                    onPath[--x][y] = true;
                } else {
                    // сдвигаемся влево
                    onPath[x][--y] = true;
                }
            }

            // Выводим путь на экран в нужном формате
            System.out.println("Output:");
            for (int i = 0; i < n; ++i){
                for (int j = 0; j < n; ++j){
                    if ((i == 0) && (j == 0)){
                        // начальная клетка
                        System.out.print('A');
                    } else if ((i == n - 1) && (j == n - 1)) {
                        // конечная клетка
                        System.out.print('B');
                    } else if (onPath[i][j]){
                        // клетки пути
                        System.out.print('*');
                    } else {
                        // остальные клетки
                        System.out.print(a[i][j]);
                    }
                    System.out.print(' ');
                }
                System.out.println();
            }


        }

    }

}
